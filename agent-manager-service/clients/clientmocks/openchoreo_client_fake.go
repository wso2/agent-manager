// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package clientmocks

import (
	"context"
	"sync"

	"github.com/wso2/ai-agent-management-platform/agent-manager-service/clients/openchoreosvc/client"
	"github.com/wso2/ai-agent-management-platform/agent-manager-service/models"
)

// OpenChoreoClientMock is a mock implementation of client.OpenChoreoClient.
//
//	func TestSomethingThatUsesOpenChoreoClient(t *testing.T) {
//
//		// make and configure a mocked client.OpenChoreoClient
//		mockedOpenChoreoClient := &OpenChoreoClientMock{
//			ApplyResourceFunc: func(ctx context.Context, body map[string]interface{}) error {
//				panic("mock out the ApplyResource method")
//			},
//			AttachTraitFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType, agentApiKey ...string) error {
//				panic("mock out the AttachTrait method")
//			},
//			ComponentExistsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, verifyProject bool) (bool, error) {
//				panic("mock out the ComponentExists method")
//			},
//			CreateComponentFunc: func(ctx context.Context, namespaceName string, projectName string, req client.CreateComponentRequest) error {
//				panic("mock out the CreateComponent method")
//			},
//			CreateProjectFunc: func(ctx context.Context, namespaceName string, req client.CreateProjectRequest) error {
//				panic("mock out the CreateProject method")
//			},
//			DeleteComponentFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string) error {
//				panic("mock out the DeleteComponent method")
//			},
//			DeleteProjectFunc: func(ctx context.Context, namespaceName string, projectName string) error {
//				panic("mock out the DeleteProject method")
//			},
//			DeleteResourceFunc: func(ctx context.Context, body map[string]interface{}) error {
//				panic("mock out the DeleteResource method")
//			},
//			DeployFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.DeployRequest) error {
//				panic("mock out the Deploy method")
//			},
//			DetachTraitFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) error {
//				panic("mock out the DetachTrait method")
//			},
//			GetBuildFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, buildName string) (*models.BuildDetailsResponse, error) {
//				panic("mock out the GetBuild method")
//			},
//			GetComponentFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string) (*models.AgentResponse, error) {
//				panic("mock out the GetComponent method")
//			},
//			GetComponentConfigurationsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) ([]models.EnvVars, error) {
//				panic("mock out the GetComponentConfigurations method")
//			},
//			GetComponentEndpointsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (map[string]models.EndpointsResponse, error) {
//				panic("mock out the GetComponentEndpoints method")
//			},
//			GetComponentResourceConfigsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (*client.ComponentResourceConfigsResponse, error) {
//				panic("mock out the GetComponentResourceConfigs method")
//			},
//			GetDeploymentsFunc: func(ctx context.Context, namespaceName string, pipelineName string, projectName string, componentName string) ([]*models.DeploymentResponse, error) {
//				panic("mock out the GetDeployments method")
//			},
//			GetEnvironmentFunc: func(ctx context.Context, namespaceName string, environmentName string) (*models.EnvironmentResponse, error) {
//				panic("mock out the GetEnvironment method")
//			},
//			GetOrganizationFunc: func(ctx context.Context, orgName string) (*models.OrganizationResponse, error) {
//				panic("mock out the GetOrganization method")
//			},
//			GetProjectFunc: func(ctx context.Context, namespaceName string, projectName string) (*models.ProjectResponse, error) {
//				panic("mock out the GetProject method")
//			},
//			GetProjectDeploymentPipelineFunc: func(ctx context.Context, namespaceName string, projectName string) (*models.DeploymentPipelineResponse, error) {
//				panic("mock out the GetProjectDeploymentPipeline method")
//			},
//			GetResourceFunc: func(ctx context.Context, namespaceName string, kind string, name string) (map[string]interface{}, error) {
//				panic("mock out the GetResource method")
//			},
//			HasTraitFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) (bool, error) {
//				panic("mock out the HasTrait method")
//			},
//			ListBuildsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string) ([]*models.BuildResponse, error) {
//				panic("mock out the ListBuilds method")
//			},
//			ListComponentsFunc: func(ctx context.Context, namespaceName string, projectName string) ([]*models.AgentResponse, error) {
//				panic("mock out the ListComponents method")
//			},
//			ListDataPlanesFunc: func(ctx context.Context, namespaceName string) ([]*models.DataPlaneResponse, error) {
//				panic("mock out the ListDataPlanes method")
//			},
//			ListDeploymentPipelinesFunc: func(ctx context.Context, namespaceName string) ([]*models.DeploymentPipelineResponse, error) {
//				panic("mock out the ListDeploymentPipelines method")
//			},
//			ListEnvironmentsFunc: func(ctx context.Context, namespaceName string) ([]*models.EnvironmentResponse, error) {
//				panic("mock out the ListEnvironments method")
//			},
//			ListOrganizationsFunc: func(ctx context.Context) ([]*models.OrganizationResponse, error) {
//				panic("mock out the ListOrganizations method")
//			},
//			ListProjectsFunc: func(ctx context.Context, namespaceName string) ([]*models.ProjectResponse, error) {
//				panic("mock out the ListProjects method")
//			},
//			PatchProjectFunc: func(ctx context.Context, namespaceName string, projectName string, req client.PatchProjectRequest) error {
//				panic("mock out the PatchProject method")
//			},
//			TriggerBuildFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, commitID string) (*models.BuildResponse, error) {
//				panic("mock out the TriggerBuild method")
//			},
//			UpdateComponentBasicInfoFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBasicInfoRequest) error {
//				panic("mock out the UpdateComponentBasicInfo method")
//			},
//			UpdateComponentBuildParametersFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBuildParametersRequest) error {
//				panic("mock out the UpdateComponentBuildParameters method")
//			},
//			UpdateComponentEnvironmentVariablesFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, envVars []client.EnvVar) error {
//				panic("mock out the UpdateComponentEnvironmentVariables method")
//			},
//			UpdateComponentResourceConfigsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string, req client.UpdateComponentResourceConfigsRequest) error {
//				panic("mock out the UpdateComponentResourceConfigs method")
//			},
//		}
//
//		// use mockedOpenChoreoClient in code that requires client.OpenChoreoClient
//		// and then make assertions.
//
//	}
type OpenChoreoClientMock struct {
	// ApplyResourceFunc mocks the ApplyResource method.
	ApplyResourceFunc func(ctx context.Context, body map[string]interface{}) error

	// AttachTraitFunc mocks the AttachTrait method.
	AttachTraitFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType, agentApiKey ...string) error

	// ComponentExistsFunc mocks the ComponentExists method.
	ComponentExistsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, verifyProject bool) (bool, error)

	// CreateComponentFunc mocks the CreateComponent method.
	CreateComponentFunc func(ctx context.Context, namespaceName string, projectName string, req client.CreateComponentRequest) error

	// CreateProjectFunc mocks the CreateProject method.
	CreateProjectFunc func(ctx context.Context, namespaceName string, req client.CreateProjectRequest) error

	// DeleteComponentFunc mocks the DeleteComponent method.
	DeleteComponentFunc func(ctx context.Context, namespaceName string, projectName string, componentName string) error

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(ctx context.Context, namespaceName string, projectName string) error

	// DeleteResourceFunc mocks the DeleteResource method.
	DeleteResourceFunc func(ctx context.Context, body map[string]interface{}) error

	// DeployFunc mocks the Deploy method.
	DeployFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.DeployRequest) error

	// DetachTraitFunc mocks the DetachTrait method.
	DetachTraitFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) error

	// GetBuildFunc mocks the GetBuild method.
	GetBuildFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, buildName string) (*models.BuildDetailsResponse, error)

	// GetComponentFunc mocks the GetComponent method.
	GetComponentFunc func(ctx context.Context, namespaceName string, projectName string, componentName string) (*models.AgentResponse, error)

	// GetComponentConfigurationsFunc mocks the GetComponentConfigurations method.
	GetComponentConfigurationsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) ([]models.EnvVars, error)

	// GetComponentEndpointsFunc mocks the GetComponentEndpoints method.
	GetComponentEndpointsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (map[string]models.EndpointsResponse, error)

	// GetComponentResourceConfigsFunc mocks the GetComponentResourceConfigs method.
	GetComponentResourceConfigsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (*client.ComponentResourceConfigsResponse, error)

	// GetDeploymentsFunc mocks the GetDeployments method.
	GetDeploymentsFunc func(ctx context.Context, namespaceName string, pipelineName string, projectName string, componentName string) ([]*models.DeploymentResponse, error)

	// GetEnvironmentFunc mocks the GetEnvironment method.
	GetEnvironmentFunc func(ctx context.Context, namespaceName string, environmentName string) (*models.EnvironmentResponse, error)

	// GetOrganizationFunc mocks the GetOrganization method.
	GetOrganizationFunc func(ctx context.Context, orgName string) (*models.OrganizationResponse, error)

	// GetProjectFunc mocks the GetProject method.
	GetProjectFunc func(ctx context.Context, namespaceName string, projectName string) (*models.ProjectResponse, error)

	// GetProjectDeploymentPipelineFunc mocks the GetProjectDeploymentPipeline method.
	GetProjectDeploymentPipelineFunc func(ctx context.Context, namespaceName string, projectName string) (*models.DeploymentPipelineResponse, error)

	// GetResourceFunc mocks the GetResource method.
	GetResourceFunc func(ctx context.Context, namespaceName string, kind string, name string) (map[string]interface{}, error)

	// HasTraitFunc mocks the HasTrait method.
	HasTraitFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) (bool, error)

	// ListBuildsFunc mocks the ListBuilds method.
	ListBuildsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string) ([]*models.BuildResponse, error)

	// ListComponentsFunc mocks the ListComponents method.
	ListComponentsFunc func(ctx context.Context, namespaceName string, projectName string) ([]*models.AgentResponse, error)

	// ListDataPlanesFunc mocks the ListDataPlanes method.
	ListDataPlanesFunc func(ctx context.Context, namespaceName string) ([]*models.DataPlaneResponse, error)

	// ListDeploymentPipelinesFunc mocks the ListDeploymentPipelines method.
	ListDeploymentPipelinesFunc func(ctx context.Context, namespaceName string) ([]*models.DeploymentPipelineResponse, error)

	// ListEnvironmentsFunc mocks the ListEnvironments method.
	ListEnvironmentsFunc func(ctx context.Context, namespaceName string) ([]*models.EnvironmentResponse, error)

	// ListOrganizationsFunc mocks the ListOrganizations method.
	ListOrganizationsFunc func(ctx context.Context) ([]*models.OrganizationResponse, error)

	// ListProjectsFunc mocks the ListProjects method.
	ListProjectsFunc func(ctx context.Context, namespaceName string) ([]*models.ProjectResponse, error)

	// PatchProjectFunc mocks the PatchProject method.
	PatchProjectFunc func(ctx context.Context, namespaceName string, projectName string, req client.PatchProjectRequest) error

	// TriggerBuildFunc mocks the TriggerBuild method.
	TriggerBuildFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, commitID string) (*models.BuildResponse, error)

	// UpdateComponentBasicInfoFunc mocks the UpdateComponentBasicInfo method.
	UpdateComponentBasicInfoFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBasicInfoRequest) error

	// UpdateComponentBuildParametersFunc mocks the UpdateComponentBuildParameters method.
	UpdateComponentBuildParametersFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBuildParametersRequest) error

	// UpdateComponentEnvironmentVariablesFunc mocks the UpdateComponentEnvironmentVariables method.
	UpdateComponentEnvironmentVariablesFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, envVars []client.EnvVar) error

	// UpdateComponentResourceConfigsFunc mocks the UpdateComponentResourceConfigs method.
	UpdateComponentResourceConfigsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string, req client.UpdateComponentResourceConfigsRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// ApplyResource holds details about calls to the ApplyResource method.
		ApplyResource []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Body is the body argument value.
			Body map[string]interface{}
		}
		// AttachTrait holds details about calls to the AttachTrait method.
		AttachTrait []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// TraitType is the traitType argument value.
			TraitType client.TraitType
			// AgentApiKey is the agentApiKey argument value.
			AgentApiKey []string
		}
		// ComponentExists holds details about calls to the ComponentExists method.
		ComponentExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// VerifyProject is the verifyProject argument value.
			VerifyProject bool
		}
		// CreateComponent holds details about calls to the CreateComponent method.
		CreateComponent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// Req is the req argument value.
			Req client.CreateComponentRequest
		}
		// CreateProject holds details about calls to the CreateProject method.
		CreateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// Req is the req argument value.
			Req client.CreateProjectRequest
		}
		// DeleteComponent holds details about calls to the DeleteComponent method.
		DeleteComponent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// DeleteResource holds details about calls to the DeleteResource method.
		DeleteResource []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Body is the body argument value.
			Body map[string]interface{}
		}
		// Deploy holds details about calls to the Deploy method.
		Deploy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Req is the req argument value.
			Req client.DeployRequest
		}
		// DetachTrait holds details about calls to the DetachTrait method.
		DetachTrait []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// TraitType is the traitType argument value.
			TraitType client.TraitType
		}
		// GetBuild holds details about calls to the GetBuild method.
		GetBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// BuildName is the buildName argument value.
			BuildName string
		}
		// GetComponent holds details about calls to the GetComponent method.
		GetComponent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// GetComponentConfigurations holds details about calls to the GetComponentConfigurations method.
		GetComponentConfigurations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Environment is the environment argument value.
			Environment string
		}
		// GetComponentEndpoints holds details about calls to the GetComponentEndpoints method.
		GetComponentEndpoints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Environment is the environment argument value.
			Environment string
		}
		// GetComponentResourceConfigs holds details about calls to the GetComponentResourceConfigs method.
		GetComponentResourceConfigs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Environment is the environment argument value.
			Environment string
		}
		// GetDeployments holds details about calls to the GetDeployments method.
		GetDeployments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// PipelineName is the pipelineName argument value.
			PipelineName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// GetEnvironment holds details about calls to the GetEnvironment method.
		GetEnvironment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// EnvironmentName is the environmentName argument value.
			EnvironmentName string
		}
		// GetOrganization holds details about calls to the GetOrganization method.
		GetOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrgName is the orgName argument value.
			OrgName string
		}
		// GetProject holds details about calls to the GetProject method.
		GetProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// GetProjectDeploymentPipeline holds details about calls to the GetProjectDeploymentPipeline method.
		GetProjectDeploymentPipeline []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// GetResource holds details about calls to the GetResource method.
		GetResource []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// Kind is the kind argument value.
			Kind string
			// Name is the name argument value.
			Name string
		}
		// HasTrait holds details about calls to the HasTrait method.
		HasTrait []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// TraitType is the traitType argument value.
			TraitType client.TraitType
		}
		// ListBuilds holds details about calls to the ListBuilds method.
		ListBuilds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// ListComponents holds details about calls to the ListComponents method.
		ListComponents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// ListDataPlanes holds details about calls to the ListDataPlanes method.
		ListDataPlanes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// ListDeploymentPipelines holds details about calls to the ListDeploymentPipelines method.
		ListDeploymentPipelines []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// ListEnvironments holds details about calls to the ListEnvironments method.
		ListEnvironments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// ListOrganizations holds details about calls to the ListOrganizations method.
		ListOrganizations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListProjects holds details about calls to the ListProjects method.
		ListProjects []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// PatchProject holds details about calls to the PatchProject method.
		PatchProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// Req is the req argument value.
			Req client.PatchProjectRequest
		}
		// TriggerBuild holds details about calls to the TriggerBuild method.
		TriggerBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// CommitID is the commitID argument value.
			CommitID string
		}
		// UpdateComponentBasicInfo holds details about calls to the UpdateComponentBasicInfo method.
		UpdateComponentBasicInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Req is the req argument value.
			Req client.UpdateComponentBasicInfoRequest
		}
		// UpdateComponentBuildParameters holds details about calls to the UpdateComponentBuildParameters method.
		UpdateComponentBuildParameters []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Req is the req argument value.
			Req client.UpdateComponentBuildParametersRequest
		}
		// UpdateComponentEnvironmentVariables holds details about calls to the UpdateComponentEnvironmentVariables method.
		UpdateComponentEnvironmentVariables []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// EnvVars is the envVars argument value.
			EnvVars []client.EnvVar
		}
		// UpdateComponentResourceConfigs holds details about calls to the UpdateComponentResourceConfigs method.
		UpdateComponentResourceConfigs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Environment is the environment argument value.
			Environment string
			// Req is the req argument value.
			Req client.UpdateComponentResourceConfigsRequest
		}
	}
	lockApplyResource                       sync.RWMutex
	lockAttachTrait                         sync.RWMutex
	lockComponentExists                     sync.RWMutex
	lockCreateComponent                     sync.RWMutex
	lockCreateProject                       sync.RWMutex
	lockDeleteComponent                     sync.RWMutex
	lockDeleteProject                       sync.RWMutex
	lockDeleteResource                      sync.RWMutex
	lockDeploy                              sync.RWMutex
	lockDetachTrait                         sync.RWMutex
	lockGetBuild                            sync.RWMutex
	lockGetComponent                        sync.RWMutex
	lockGetComponentConfigurations          sync.RWMutex
	lockGetComponentEndpoints               sync.RWMutex
	lockGetComponentResourceConfigs         sync.RWMutex
	lockGetDeployments                      sync.RWMutex
	lockGetEnvironment                      sync.RWMutex
	lockGetOrganization                     sync.RWMutex
	lockGetProject                          sync.RWMutex
	lockGetProjectDeploymentPipeline        sync.RWMutex
	lockGetResource                         sync.RWMutex
	lockHasTrait                            sync.RWMutex
	lockListBuilds                          sync.RWMutex
	lockListComponents                      sync.RWMutex
	lockListDataPlanes                      sync.RWMutex
	lockListDeploymentPipelines             sync.RWMutex
	lockListEnvironments                    sync.RWMutex
	lockListOrganizations                   sync.RWMutex
	lockListProjects                        sync.RWMutex
	lockPatchProject                        sync.RWMutex
	lockTriggerBuild                        sync.RWMutex
	lockUpdateComponentBasicInfo            sync.RWMutex
	lockUpdateComponentBuildParameters      sync.RWMutex
	lockUpdateComponentEnvironmentVariables sync.RWMutex
	lockUpdateComponentResourceConfigs      sync.RWMutex
}

// ApplyResource calls ApplyResourceFunc.
func (mock *OpenChoreoClientMock) ApplyResource(ctx context.Context, body map[string]interface{}) error {
	if mock.ApplyResourceFunc == nil {
		panic("OpenChoreoClientMock.ApplyResourceFunc: method is nil but OpenChoreoClient.ApplyResource was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Body map[string]interface{}
	}{
		Ctx:  ctx,
		Body: body,
	}
	mock.lockApplyResource.Lock()
	mock.calls.ApplyResource = append(mock.calls.ApplyResource, callInfo)
	mock.lockApplyResource.Unlock()
	return mock.ApplyResourceFunc(ctx, body)
}

// ApplyResourceCalls gets all the calls that were made to ApplyResource.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ApplyResourceCalls())
func (mock *OpenChoreoClientMock) ApplyResourceCalls() []struct {
	Ctx  context.Context
	Body map[string]interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Body map[string]interface{}
	}
	mock.lockApplyResource.RLock()
	calls = mock.calls.ApplyResource
	mock.lockApplyResource.RUnlock()
	return calls
}

// AttachTrait calls AttachTraitFunc.
func (mock *OpenChoreoClientMock) AttachTrait(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType, agentApiKey ...string) error {
	if mock.AttachTraitFunc == nil {
		panic("OpenChoreoClientMock.AttachTraitFunc: method is nil but OpenChoreoClient.AttachTrait was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
		AgentApiKey   []string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		TraitType:     traitType,
		AgentApiKey:   agentApiKey,
	}
	mock.lockAttachTrait.Lock()
	mock.calls.AttachTrait = append(mock.calls.AttachTrait, callInfo)
	mock.lockAttachTrait.Unlock()
	return mock.AttachTraitFunc(ctx, namespaceName, projectName, componentName, traitType, agentApiKey...)
}

// AttachTraitCalls gets all the calls that were made to AttachTrait.
// Check the length with:
//
//	len(mockedOpenChoreoClient.AttachTraitCalls())
func (mock *OpenChoreoClientMock) AttachTraitCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	TraitType     client.TraitType
	AgentApiKey   []string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
		AgentApiKey   []string
	}
	mock.lockAttachTrait.RLock()
	calls = mock.calls.AttachTrait
	mock.lockAttachTrait.RUnlock()
	return calls
}

// ComponentExists calls ComponentExistsFunc.
func (mock *OpenChoreoClientMock) ComponentExists(ctx context.Context, namespaceName string, projectName string, componentName string, verifyProject bool) (bool, error) {
	if mock.ComponentExistsFunc == nil {
		panic("OpenChoreoClientMock.ComponentExistsFunc: method is nil but OpenChoreoClient.ComponentExists was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		VerifyProject bool
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		VerifyProject: verifyProject,
	}
	mock.lockComponentExists.Lock()
	mock.calls.ComponentExists = append(mock.calls.ComponentExists, callInfo)
	mock.lockComponentExists.Unlock()
	return mock.ComponentExistsFunc(ctx, namespaceName, projectName, componentName, verifyProject)
}

// ComponentExistsCalls gets all the calls that were made to ComponentExists.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ComponentExistsCalls())
func (mock *OpenChoreoClientMock) ComponentExistsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	VerifyProject bool
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		VerifyProject bool
	}
	mock.lockComponentExists.RLock()
	calls = mock.calls.ComponentExists
	mock.lockComponentExists.RUnlock()
	return calls
}

// CreateComponent calls CreateComponentFunc.
func (mock *OpenChoreoClientMock) CreateComponent(ctx context.Context, namespaceName string, projectName string, req client.CreateComponentRequest) error {
	if mock.CreateComponentFunc == nil {
		panic("OpenChoreoClientMock.CreateComponentFunc: method is nil but OpenChoreoClient.CreateComponent was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.CreateComponentRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		Req:           req,
	}
	mock.lockCreateComponent.Lock()
	mock.calls.CreateComponent = append(mock.calls.CreateComponent, callInfo)
	mock.lockCreateComponent.Unlock()
	return mock.CreateComponentFunc(ctx, namespaceName, projectName, req)
}

// CreateComponentCalls gets all the calls that were made to CreateComponent.
// Check the length with:
//
//	len(mockedOpenChoreoClient.CreateComponentCalls())
func (mock *OpenChoreoClientMock) CreateComponentCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	Req           client.CreateComponentRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.CreateComponentRequest
	}
	mock.lockCreateComponent.RLock()
	calls = mock.calls.CreateComponent
	mock.lockCreateComponent.RUnlock()
	return calls
}

// CreateProject calls CreateProjectFunc.
func (mock *OpenChoreoClientMock) CreateProject(ctx context.Context, namespaceName string, req client.CreateProjectRequest) error {
	if mock.CreateProjectFunc == nil {
		panic("OpenChoreoClientMock.CreateProjectFunc: method is nil but OpenChoreoClient.CreateProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		Req           client.CreateProjectRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		Req:           req,
	}
	mock.lockCreateProject.Lock()
	mock.calls.CreateProject = append(mock.calls.CreateProject, callInfo)
	mock.lockCreateProject.Unlock()
	return mock.CreateProjectFunc(ctx, namespaceName, req)
}

// CreateProjectCalls gets all the calls that were made to CreateProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.CreateProjectCalls())
func (mock *OpenChoreoClientMock) CreateProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	Req           client.CreateProjectRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		Req           client.CreateProjectRequest
	}
	mock.lockCreateProject.RLock()
	calls = mock.calls.CreateProject
	mock.lockCreateProject.RUnlock()
	return calls
}

// DeleteComponent calls DeleteComponentFunc.
func (mock *OpenChoreoClientMock) DeleteComponent(ctx context.Context, namespaceName string, projectName string, componentName string) error {
	if mock.DeleteComponentFunc == nil {
		panic("OpenChoreoClientMock.DeleteComponentFunc: method is nil but OpenChoreoClient.DeleteComponent was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockDeleteComponent.Lock()
	mock.calls.DeleteComponent = append(mock.calls.DeleteComponent, callInfo)
	mock.lockDeleteComponent.Unlock()
	return mock.DeleteComponentFunc(ctx, namespaceName, projectName, componentName)
}

// DeleteComponentCalls gets all the calls that were made to DeleteComponent.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeleteComponentCalls())
func (mock *OpenChoreoClientMock) DeleteComponentCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}
	mock.lockDeleteComponent.RLock()
	calls = mock.calls.DeleteComponent
	mock.lockDeleteComponent.RUnlock()
	return calls
}

// DeleteProject calls DeleteProjectFunc.
func (mock *OpenChoreoClientMock) DeleteProject(ctx context.Context, namespaceName string, projectName string) error {
	if mock.DeleteProjectFunc == nil {
		panic("OpenChoreoClientMock.DeleteProjectFunc: method is nil but OpenChoreoClient.DeleteProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(ctx, namespaceName, projectName)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeleteProjectCalls())
func (mock *OpenChoreoClientMock) DeleteProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// DeleteResource calls DeleteResourceFunc.
func (mock *OpenChoreoClientMock) DeleteResource(ctx context.Context, body map[string]interface{}) error {
	if mock.DeleteResourceFunc == nil {
		panic("OpenChoreoClientMock.DeleteResourceFunc: method is nil but OpenChoreoClient.DeleteResource was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Body map[string]interface{}
	}{
		Ctx:  ctx,
		Body: body,
	}
	mock.lockDeleteResource.Lock()
	mock.calls.DeleteResource = append(mock.calls.DeleteResource, callInfo)
	mock.lockDeleteResource.Unlock()
	return mock.DeleteResourceFunc(ctx, body)
}

// DeleteResourceCalls gets all the calls that were made to DeleteResource.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeleteResourceCalls())
func (mock *OpenChoreoClientMock) DeleteResourceCalls() []struct {
	Ctx  context.Context
	Body map[string]interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Body map[string]interface{}
	}
	mock.lockDeleteResource.RLock()
	calls = mock.calls.DeleteResource
	mock.lockDeleteResource.RUnlock()
	return calls
}

// Deploy calls DeployFunc.
func (mock *OpenChoreoClientMock) Deploy(ctx context.Context, namespaceName string, projectName string, componentName string, req client.DeployRequest) error {
	if mock.DeployFunc == nil {
		panic("OpenChoreoClientMock.DeployFunc: method is nil but OpenChoreoClient.Deploy was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.DeployRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Req:           req,
	}
	mock.lockDeploy.Lock()
	mock.calls.Deploy = append(mock.calls.Deploy, callInfo)
	mock.lockDeploy.Unlock()
	return mock.DeployFunc(ctx, namespaceName, projectName, componentName, req)
}

// DeployCalls gets all the calls that were made to Deploy.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeployCalls())
func (mock *OpenChoreoClientMock) DeployCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Req           client.DeployRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.DeployRequest
	}
	mock.lockDeploy.RLock()
	calls = mock.calls.Deploy
	mock.lockDeploy.RUnlock()
	return calls
}

// DetachTrait calls DetachTraitFunc.
func (mock *OpenChoreoClientMock) DetachTrait(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) error {
	if mock.DetachTraitFunc == nil {
		panic("OpenChoreoClientMock.DetachTraitFunc: method is nil but OpenChoreoClient.DetachTrait was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		TraitType:     traitType,
	}
	mock.lockDetachTrait.Lock()
	mock.calls.DetachTrait = append(mock.calls.DetachTrait, callInfo)
	mock.lockDetachTrait.Unlock()
	return mock.DetachTraitFunc(ctx, namespaceName, projectName, componentName, traitType)
}

// DetachTraitCalls gets all the calls that were made to DetachTrait.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DetachTraitCalls())
func (mock *OpenChoreoClientMock) DetachTraitCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	TraitType     client.TraitType
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
	}
	mock.lockDetachTrait.RLock()
	calls = mock.calls.DetachTrait
	mock.lockDetachTrait.RUnlock()
	return calls
}

// GetBuild calls GetBuildFunc.
func (mock *OpenChoreoClientMock) GetBuild(ctx context.Context, namespaceName string, projectName string, componentName string, buildName string) (*models.BuildDetailsResponse, error) {
	if mock.GetBuildFunc == nil {
		panic("OpenChoreoClientMock.GetBuildFunc: method is nil but OpenChoreoClient.GetBuild was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		BuildName     string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		BuildName:     buildName,
	}
	mock.lockGetBuild.Lock()
	mock.calls.GetBuild = append(mock.calls.GetBuild, callInfo)
	mock.lockGetBuild.Unlock()
	return mock.GetBuildFunc(ctx, namespaceName, projectName, componentName, buildName)
}

// GetBuildCalls gets all the calls that were made to GetBuild.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetBuildCalls())
func (mock *OpenChoreoClientMock) GetBuildCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	BuildName     string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		BuildName     string
	}
	mock.lockGetBuild.RLock()
	calls = mock.calls.GetBuild
	mock.lockGetBuild.RUnlock()
	return calls
}

// GetComponent calls GetComponentFunc.
func (mock *OpenChoreoClientMock) GetComponent(ctx context.Context, namespaceName string, projectName string, componentName string) (*models.AgentResponse, error) {
	if mock.GetComponentFunc == nil {
		panic("OpenChoreoClientMock.GetComponentFunc: method is nil but OpenChoreoClient.GetComponent was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockGetComponent.Lock()
	mock.calls.GetComponent = append(mock.calls.GetComponent, callInfo)
	mock.lockGetComponent.Unlock()
	return mock.GetComponentFunc(ctx, namespaceName, projectName, componentName)
}

// GetComponentCalls gets all the calls that were made to GetComponent.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentCalls())
func (mock *OpenChoreoClientMock) GetComponentCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}
	mock.lockGetComponent.RLock()
	calls = mock.calls.GetComponent
	mock.lockGetComponent.RUnlock()
	return calls
}

// GetComponentConfigurations calls GetComponentConfigurationsFunc.
func (mock *OpenChoreoClientMock) GetComponentConfigurations(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) ([]models.EnvVars, error) {
	if mock.GetComponentConfigurationsFunc == nil {
		panic("OpenChoreoClientMock.GetComponentConfigurationsFunc: method is nil but OpenChoreoClient.GetComponentConfigurations was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Environment:   environment,
	}
	mock.lockGetComponentConfigurations.Lock()
	mock.calls.GetComponentConfigurations = append(mock.calls.GetComponentConfigurations, callInfo)
	mock.lockGetComponentConfigurations.Unlock()
	return mock.GetComponentConfigurationsFunc(ctx, namespaceName, projectName, componentName, environment)
}

// GetComponentConfigurationsCalls gets all the calls that were made to GetComponentConfigurations.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentConfigurationsCalls())
func (mock *OpenChoreoClientMock) GetComponentConfigurationsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Environment   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}
	mock.lockGetComponentConfigurations.RLock()
	calls = mock.calls.GetComponentConfigurations
	mock.lockGetComponentConfigurations.RUnlock()
	return calls
}

// GetComponentEndpoints calls GetComponentEndpointsFunc.
func (mock *OpenChoreoClientMock) GetComponentEndpoints(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (map[string]models.EndpointsResponse, error) {
	if mock.GetComponentEndpointsFunc == nil {
		panic("OpenChoreoClientMock.GetComponentEndpointsFunc: method is nil but OpenChoreoClient.GetComponentEndpoints was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Environment:   environment,
	}
	mock.lockGetComponentEndpoints.Lock()
	mock.calls.GetComponentEndpoints = append(mock.calls.GetComponentEndpoints, callInfo)
	mock.lockGetComponentEndpoints.Unlock()
	return mock.GetComponentEndpointsFunc(ctx, namespaceName, projectName, componentName, environment)
}

// GetComponentEndpointsCalls gets all the calls that were made to GetComponentEndpoints.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentEndpointsCalls())
func (mock *OpenChoreoClientMock) GetComponentEndpointsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Environment   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}
	mock.lockGetComponentEndpoints.RLock()
	calls = mock.calls.GetComponentEndpoints
	mock.lockGetComponentEndpoints.RUnlock()
	return calls
}

// GetComponentResourceConfigs calls GetComponentResourceConfigsFunc.
func (mock *OpenChoreoClientMock) GetComponentResourceConfigs(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (*client.ComponentResourceConfigsResponse, error) {
	if mock.GetComponentResourceConfigsFunc == nil {
		panic("OpenChoreoClientMock.GetComponentResourceConfigsFunc: method is nil but OpenChoreoClient.GetComponentResourceConfigs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Environment:   environment,
	}
	mock.lockGetComponentResourceConfigs.Lock()
	mock.calls.GetComponentResourceConfigs = append(mock.calls.GetComponentResourceConfigs, callInfo)
	mock.lockGetComponentResourceConfigs.Unlock()
	return mock.GetComponentResourceConfigsFunc(ctx, namespaceName, projectName, componentName, environment)
}

// GetComponentResourceConfigsCalls gets all the calls that were made to GetComponentResourceConfigs.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentResourceConfigsCalls())
func (mock *OpenChoreoClientMock) GetComponentResourceConfigsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Environment   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}
	mock.lockGetComponentResourceConfigs.RLock()
	calls = mock.calls.GetComponentResourceConfigs
	mock.lockGetComponentResourceConfigs.RUnlock()
	return calls
}

// GetDeployments calls GetDeploymentsFunc.
func (mock *OpenChoreoClientMock) GetDeployments(ctx context.Context, namespaceName string, pipelineName string, projectName string, componentName string) ([]*models.DeploymentResponse, error) {
	if mock.GetDeploymentsFunc == nil {
		panic("OpenChoreoClientMock.GetDeploymentsFunc: method is nil but OpenChoreoClient.GetDeployments was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		PipelineName  string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		PipelineName:  pipelineName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockGetDeployments.Lock()
	mock.calls.GetDeployments = append(mock.calls.GetDeployments, callInfo)
	mock.lockGetDeployments.Unlock()
	return mock.GetDeploymentsFunc(ctx, namespaceName, pipelineName, projectName, componentName)
}

// GetDeploymentsCalls gets all the calls that were made to GetDeployments.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetDeploymentsCalls())
func (mock *OpenChoreoClientMock) GetDeploymentsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	PipelineName  string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		PipelineName  string
		ProjectName   string
		ComponentName string
	}
	mock.lockGetDeployments.RLock()
	calls = mock.calls.GetDeployments
	mock.lockGetDeployments.RUnlock()
	return calls
}

// GetEnvironment calls GetEnvironmentFunc.
func (mock *OpenChoreoClientMock) GetEnvironment(ctx context.Context, namespaceName string, environmentName string) (*models.EnvironmentResponse, error) {
	if mock.GetEnvironmentFunc == nil {
		panic("OpenChoreoClientMock.GetEnvironmentFunc: method is nil but OpenChoreoClient.GetEnvironment was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		NamespaceName   string
		EnvironmentName string
	}{
		Ctx:             ctx,
		NamespaceName:   namespaceName,
		EnvironmentName: environmentName,
	}
	mock.lockGetEnvironment.Lock()
	mock.calls.GetEnvironment = append(mock.calls.GetEnvironment, callInfo)
	mock.lockGetEnvironment.Unlock()
	return mock.GetEnvironmentFunc(ctx, namespaceName, environmentName)
}

// GetEnvironmentCalls gets all the calls that were made to GetEnvironment.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetEnvironmentCalls())
func (mock *OpenChoreoClientMock) GetEnvironmentCalls() []struct {
	Ctx             context.Context
	NamespaceName   string
	EnvironmentName string
} {
	var calls []struct {
		Ctx             context.Context
		NamespaceName   string
		EnvironmentName string
	}
	mock.lockGetEnvironment.RLock()
	calls = mock.calls.GetEnvironment
	mock.lockGetEnvironment.RUnlock()
	return calls
}

// GetOrganization calls GetOrganizationFunc.
func (mock *OpenChoreoClientMock) GetOrganization(ctx context.Context, orgName string) (*models.OrganizationResponse, error) {
	if mock.GetOrganizationFunc == nil {
		panic("OpenChoreoClientMock.GetOrganizationFunc: method is nil but OpenChoreoClient.GetOrganization was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OrgName string
	}{
		Ctx:     ctx,
		OrgName: orgName,
	}
	mock.lockGetOrganization.Lock()
	mock.calls.GetOrganization = append(mock.calls.GetOrganization, callInfo)
	mock.lockGetOrganization.Unlock()
	return mock.GetOrganizationFunc(ctx, orgName)
}

// GetOrganizationCalls gets all the calls that were made to GetOrganization.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetOrganizationCalls())
func (mock *OpenChoreoClientMock) GetOrganizationCalls() []struct {
	Ctx     context.Context
	OrgName string
} {
	var calls []struct {
		Ctx     context.Context
		OrgName string
	}
	mock.lockGetOrganization.RLock()
	calls = mock.calls.GetOrganization
	mock.lockGetOrganization.RUnlock()
	return calls
}

// GetProject calls GetProjectFunc.
func (mock *OpenChoreoClientMock) GetProject(ctx context.Context, namespaceName string, projectName string) (*models.ProjectResponse, error) {
	if mock.GetProjectFunc == nil {
		panic("OpenChoreoClientMock.GetProjectFunc: method is nil but OpenChoreoClient.GetProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockGetProject.Lock()
	mock.calls.GetProject = append(mock.calls.GetProject, callInfo)
	mock.lockGetProject.Unlock()
	return mock.GetProjectFunc(ctx, namespaceName, projectName)
}

// GetProjectCalls gets all the calls that were made to GetProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetProjectCalls())
func (mock *OpenChoreoClientMock) GetProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockGetProject.RLock()
	calls = mock.calls.GetProject
	mock.lockGetProject.RUnlock()
	return calls
}

// GetProjectDeploymentPipeline calls GetProjectDeploymentPipelineFunc.
func (mock *OpenChoreoClientMock) GetProjectDeploymentPipeline(ctx context.Context, namespaceName string, projectName string) (*models.DeploymentPipelineResponse, error) {
	if mock.GetProjectDeploymentPipelineFunc == nil {
		panic("OpenChoreoClientMock.GetProjectDeploymentPipelineFunc: method is nil but OpenChoreoClient.GetProjectDeploymentPipeline was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockGetProjectDeploymentPipeline.Lock()
	mock.calls.GetProjectDeploymentPipeline = append(mock.calls.GetProjectDeploymentPipeline, callInfo)
	mock.lockGetProjectDeploymentPipeline.Unlock()
	return mock.GetProjectDeploymentPipelineFunc(ctx, namespaceName, projectName)
}

// GetProjectDeploymentPipelineCalls gets all the calls that were made to GetProjectDeploymentPipeline.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetProjectDeploymentPipelineCalls())
func (mock *OpenChoreoClientMock) GetProjectDeploymentPipelineCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockGetProjectDeploymentPipeline.RLock()
	calls = mock.calls.GetProjectDeploymentPipeline
	mock.lockGetProjectDeploymentPipeline.RUnlock()
	return calls
}

// GetResource calls GetResourceFunc.
func (mock *OpenChoreoClientMock) GetResource(ctx context.Context, namespaceName string, kind string, name string) (map[string]interface{}, error) {
	if mock.GetResourceFunc == nil {
		panic("OpenChoreoClientMock.GetResourceFunc: method is nil but OpenChoreoClient.GetResource was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		Kind          string
		Name          string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		Kind:          kind,
		Name:          name,
	}
	mock.lockGetResource.Lock()
	mock.calls.GetResource = append(mock.calls.GetResource, callInfo)
	mock.lockGetResource.Unlock()
	return mock.GetResourceFunc(ctx, namespaceName, kind, name)
}

// GetResourceCalls gets all the calls that were made to GetResource.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetResourceCalls())
func (mock *OpenChoreoClientMock) GetResourceCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	Kind          string
	Name          string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		Kind          string
		Name          string
	}
	mock.lockGetResource.RLock()
	calls = mock.calls.GetResource
	mock.lockGetResource.RUnlock()
	return calls
}

// HasTrait calls HasTraitFunc.
func (mock *OpenChoreoClientMock) HasTrait(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) (bool, error) {
	if mock.HasTraitFunc == nil {
		panic("OpenChoreoClientMock.HasTraitFunc: method is nil but OpenChoreoClient.HasTrait was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		TraitType:     traitType,
	}
	mock.lockHasTrait.Lock()
	mock.calls.HasTrait = append(mock.calls.HasTrait, callInfo)
	mock.lockHasTrait.Unlock()
	return mock.HasTraitFunc(ctx, namespaceName, projectName, componentName, traitType)
}

// HasTraitCalls gets all the calls that were made to HasTrait.
// Check the length with:
//
//	len(mockedOpenChoreoClient.HasTraitCalls())
func (mock *OpenChoreoClientMock) HasTraitCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	TraitType     client.TraitType
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
	}
	mock.lockHasTrait.RLock()
	calls = mock.calls.HasTrait
	mock.lockHasTrait.RUnlock()
	return calls
}

// ListBuilds calls ListBuildsFunc.
func (mock *OpenChoreoClientMock) ListBuilds(ctx context.Context, namespaceName string, projectName string, componentName string) ([]*models.BuildResponse, error) {
	if mock.ListBuildsFunc == nil {
		panic("OpenChoreoClientMock.ListBuildsFunc: method is nil but OpenChoreoClient.ListBuilds was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockListBuilds.Lock()
	mock.calls.ListBuilds = append(mock.calls.ListBuilds, callInfo)
	mock.lockListBuilds.Unlock()
	return mock.ListBuildsFunc(ctx, namespaceName, projectName, componentName)
}

// ListBuildsCalls gets all the calls that were made to ListBuilds.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListBuildsCalls())
func (mock *OpenChoreoClientMock) ListBuildsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}
	mock.lockListBuilds.RLock()
	calls = mock.calls.ListBuilds
	mock.lockListBuilds.RUnlock()
	return calls
}

// ListComponents calls ListComponentsFunc.
func (mock *OpenChoreoClientMock) ListComponents(ctx context.Context, namespaceName string, projectName string) ([]*models.AgentResponse, error) {
	if mock.ListComponentsFunc == nil {
		panic("OpenChoreoClientMock.ListComponentsFunc: method is nil but OpenChoreoClient.ListComponents was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockListComponents.Lock()
	mock.calls.ListComponents = append(mock.calls.ListComponents, callInfo)
	mock.lockListComponents.Unlock()
	return mock.ListComponentsFunc(ctx, namespaceName, projectName)
}

// ListComponentsCalls gets all the calls that were made to ListComponents.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListComponentsCalls())
func (mock *OpenChoreoClientMock) ListComponentsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockListComponents.RLock()
	calls = mock.calls.ListComponents
	mock.lockListComponents.RUnlock()
	return calls
}

// ListDataPlanes calls ListDataPlanesFunc.
func (mock *OpenChoreoClientMock) ListDataPlanes(ctx context.Context, namespaceName string) ([]*models.DataPlaneResponse, error) {
	if mock.ListDataPlanesFunc == nil {
		panic("OpenChoreoClientMock.ListDataPlanesFunc: method is nil but OpenChoreoClient.ListDataPlanes was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListDataPlanes.Lock()
	mock.calls.ListDataPlanes = append(mock.calls.ListDataPlanes, callInfo)
	mock.lockListDataPlanes.Unlock()
	return mock.ListDataPlanesFunc(ctx, namespaceName)
}

// ListDataPlanesCalls gets all the calls that were made to ListDataPlanes.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListDataPlanesCalls())
func (mock *OpenChoreoClientMock) ListDataPlanesCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListDataPlanes.RLock()
	calls = mock.calls.ListDataPlanes
	mock.lockListDataPlanes.RUnlock()
	return calls
}

// ListDeploymentPipelines calls ListDeploymentPipelinesFunc.
func (mock *OpenChoreoClientMock) ListDeploymentPipelines(ctx context.Context, namespaceName string) ([]*models.DeploymentPipelineResponse, error) {
	if mock.ListDeploymentPipelinesFunc == nil {
		panic("OpenChoreoClientMock.ListDeploymentPipelinesFunc: method is nil but OpenChoreoClient.ListDeploymentPipelines was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListDeploymentPipelines.Lock()
	mock.calls.ListDeploymentPipelines = append(mock.calls.ListDeploymentPipelines, callInfo)
	mock.lockListDeploymentPipelines.Unlock()
	return mock.ListDeploymentPipelinesFunc(ctx, namespaceName)
}

// ListDeploymentPipelinesCalls gets all the calls that were made to ListDeploymentPipelines.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListDeploymentPipelinesCalls())
func (mock *OpenChoreoClientMock) ListDeploymentPipelinesCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListDeploymentPipelines.RLock()
	calls = mock.calls.ListDeploymentPipelines
	mock.lockListDeploymentPipelines.RUnlock()
	return calls
}

// ListEnvironments calls ListEnvironmentsFunc.
func (mock *OpenChoreoClientMock) ListEnvironments(ctx context.Context, namespaceName string) ([]*models.EnvironmentResponse, error) {
	if mock.ListEnvironmentsFunc == nil {
		panic("OpenChoreoClientMock.ListEnvironmentsFunc: method is nil but OpenChoreoClient.ListEnvironments was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListEnvironments.Lock()
	mock.calls.ListEnvironments = append(mock.calls.ListEnvironments, callInfo)
	mock.lockListEnvironments.Unlock()
	return mock.ListEnvironmentsFunc(ctx, namespaceName)
}

// ListEnvironmentsCalls gets all the calls that were made to ListEnvironments.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListEnvironmentsCalls())
func (mock *OpenChoreoClientMock) ListEnvironmentsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListEnvironments.RLock()
	calls = mock.calls.ListEnvironments
	mock.lockListEnvironments.RUnlock()
	return calls
}

// ListOrganizations calls ListOrganizationsFunc.
func (mock *OpenChoreoClientMock) ListOrganizations(ctx context.Context) ([]*models.OrganizationResponse, error) {
	if mock.ListOrganizationsFunc == nil {
		panic("OpenChoreoClientMock.ListOrganizationsFunc: method is nil but OpenChoreoClient.ListOrganizations was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListOrganizations.Lock()
	mock.calls.ListOrganizations = append(mock.calls.ListOrganizations, callInfo)
	mock.lockListOrganizations.Unlock()
	return mock.ListOrganizationsFunc(ctx)
}

// ListOrganizationsCalls gets all the calls that were made to ListOrganizations.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListOrganizationsCalls())
func (mock *OpenChoreoClientMock) ListOrganizationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListOrganizations.RLock()
	calls = mock.calls.ListOrganizations
	mock.lockListOrganizations.RUnlock()
	return calls
}

// ListProjects calls ListProjectsFunc.
func (mock *OpenChoreoClientMock) ListProjects(ctx context.Context, namespaceName string) ([]*models.ProjectResponse, error) {
	if mock.ListProjectsFunc == nil {
		panic("OpenChoreoClientMock.ListProjectsFunc: method is nil but OpenChoreoClient.ListProjects was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListProjects.Lock()
	mock.calls.ListProjects = append(mock.calls.ListProjects, callInfo)
	mock.lockListProjects.Unlock()
	return mock.ListProjectsFunc(ctx, namespaceName)
}

// ListProjectsCalls gets all the calls that were made to ListProjects.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListProjectsCalls())
func (mock *OpenChoreoClientMock) ListProjectsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListProjects.RLock()
	calls = mock.calls.ListProjects
	mock.lockListProjects.RUnlock()
	return calls
}

// PatchProject calls PatchProjectFunc.
func (mock *OpenChoreoClientMock) PatchProject(ctx context.Context, namespaceName string, projectName string, req client.PatchProjectRequest) error {
	if mock.PatchProjectFunc == nil {
		panic("OpenChoreoClientMock.PatchProjectFunc: method is nil but OpenChoreoClient.PatchProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.PatchProjectRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		Req:           req,
	}
	mock.lockPatchProject.Lock()
	mock.calls.PatchProject = append(mock.calls.PatchProject, callInfo)
	mock.lockPatchProject.Unlock()
	return mock.PatchProjectFunc(ctx, namespaceName, projectName, req)
}

// PatchProjectCalls gets all the calls that were made to PatchProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.PatchProjectCalls())
func (mock *OpenChoreoClientMock) PatchProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	Req           client.PatchProjectRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.PatchProjectRequest
	}
	mock.lockPatchProject.RLock()
	calls = mock.calls.PatchProject
	mock.lockPatchProject.RUnlock()
	return calls
}

// TriggerBuild calls TriggerBuildFunc.
func (mock *OpenChoreoClientMock) TriggerBuild(ctx context.Context, namespaceName string, projectName string, componentName string, commitID string) (*models.BuildResponse, error) {
	if mock.TriggerBuildFunc == nil {
		panic("OpenChoreoClientMock.TriggerBuildFunc: method is nil but OpenChoreoClient.TriggerBuild was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		CommitID      string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		CommitID:      commitID,
	}
	mock.lockTriggerBuild.Lock()
	mock.calls.TriggerBuild = append(mock.calls.TriggerBuild, callInfo)
	mock.lockTriggerBuild.Unlock()
	return mock.TriggerBuildFunc(ctx, namespaceName, projectName, componentName, commitID)
}

// TriggerBuildCalls gets all the calls that were made to TriggerBuild.
// Check the length with:
//
//	len(mockedOpenChoreoClient.TriggerBuildCalls())
func (mock *OpenChoreoClientMock) TriggerBuildCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	CommitID      string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		CommitID      string
	}
	mock.lockTriggerBuild.RLock()
	calls = mock.calls.TriggerBuild
	mock.lockTriggerBuild.RUnlock()
	return calls
}

// UpdateComponentBasicInfo calls UpdateComponentBasicInfoFunc.
func (mock *OpenChoreoClientMock) UpdateComponentBasicInfo(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBasicInfoRequest) error {
	if mock.UpdateComponentBasicInfoFunc == nil {
		panic("OpenChoreoClientMock.UpdateComponentBasicInfoFunc: method is nil but OpenChoreoClient.UpdateComponentBasicInfo was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBasicInfoRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Req:           req,
	}
	mock.lockUpdateComponentBasicInfo.Lock()
	mock.calls.UpdateComponentBasicInfo = append(mock.calls.UpdateComponentBasicInfo, callInfo)
	mock.lockUpdateComponentBasicInfo.Unlock()
	return mock.UpdateComponentBasicInfoFunc(ctx, namespaceName, projectName, componentName, req)
}

// UpdateComponentBasicInfoCalls gets all the calls that were made to UpdateComponentBasicInfo.
// Check the length with:
//
//	len(mockedOpenChoreoClient.UpdateComponentBasicInfoCalls())
func (mock *OpenChoreoClientMock) UpdateComponentBasicInfoCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Req           client.UpdateComponentBasicInfoRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBasicInfoRequest
	}
	mock.lockUpdateComponentBasicInfo.RLock()
	calls = mock.calls.UpdateComponentBasicInfo
	mock.lockUpdateComponentBasicInfo.RUnlock()
	return calls
}

// UpdateComponentBuildParameters calls UpdateComponentBuildParametersFunc.
func (mock *OpenChoreoClientMock) UpdateComponentBuildParameters(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBuildParametersRequest) error {
	if mock.UpdateComponentBuildParametersFunc == nil {
		panic("OpenChoreoClientMock.UpdateComponentBuildParametersFunc: method is nil but OpenChoreoClient.UpdateComponentBuildParameters was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBuildParametersRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Req:           req,
	}
	mock.lockUpdateComponentBuildParameters.Lock()
	mock.calls.UpdateComponentBuildParameters = append(mock.calls.UpdateComponentBuildParameters, callInfo)
	mock.lockUpdateComponentBuildParameters.Unlock()
	return mock.UpdateComponentBuildParametersFunc(ctx, namespaceName, projectName, componentName, req)
}

// UpdateComponentBuildParametersCalls gets all the calls that were made to UpdateComponentBuildParameters.
// Check the length with:
//
//	len(mockedOpenChoreoClient.UpdateComponentBuildParametersCalls())
func (mock *OpenChoreoClientMock) UpdateComponentBuildParametersCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Req           client.UpdateComponentBuildParametersRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBuildParametersRequest
	}
	mock.lockUpdateComponentBuildParameters.RLock()
	calls = mock.calls.UpdateComponentBuildParameters
	mock.lockUpdateComponentBuildParameters.RUnlock()
	return calls
}

// UpdateComponentEnvironmentVariables calls UpdateComponentEnvironmentVariablesFunc.
func (mock *OpenChoreoClientMock) UpdateComponentEnvironmentVariables(ctx context.Context, namespaceName string, projectName string, componentName string, envVars []client.EnvVar) error {
	if mock.UpdateComponentEnvironmentVariablesFunc == nil {
		panic("OpenChoreoClientMock.UpdateComponentEnvironmentVariablesFunc: method is nil but OpenChoreoClient.UpdateComponentEnvironmentVariables was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		EnvVars       []client.EnvVar
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		EnvVars:       envVars,
	}
	mock.lockUpdateComponentEnvironmentVariables.Lock()
	mock.calls.UpdateComponentEnvironmentVariables = append(mock.calls.UpdateComponentEnvironmentVariables, callInfo)
	mock.lockUpdateComponentEnvironmentVariables.Unlock()
	return mock.UpdateComponentEnvironmentVariablesFunc(ctx, namespaceName, projectName, componentName, envVars)
}

// UpdateComponentEnvironmentVariablesCalls gets all the calls that were made to UpdateComponentEnvironmentVariables.
// Check the length with:
//
//	len(mockedOpenChoreoClient.UpdateComponentEnvironmentVariablesCalls())
func (mock *OpenChoreoClientMock) UpdateComponentEnvironmentVariablesCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	EnvVars       []client.EnvVar
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		EnvVars       []client.EnvVar
	}
	mock.lockUpdateComponentEnvironmentVariables.RLock()
	calls = mock.calls.UpdateComponentEnvironmentVariables
	mock.lockUpdateComponentEnvironmentVariables.RUnlock()
	return calls
}

// UpdateComponentResourceConfigs calls UpdateComponentResourceConfigsFunc.
func (mock *OpenChoreoClientMock) UpdateComponentResourceConfigs(ctx context.Context, namespaceName string, projectName string, componentName string, environment string, req client.UpdateComponentResourceConfigsRequest) error {
	if mock.UpdateComponentResourceConfigsFunc == nil {
		panic("OpenChoreoClientMock.UpdateComponentResourceConfigsFunc: method is nil but OpenChoreoClient.UpdateComponentResourceConfigs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
		Req           client.UpdateComponentResourceConfigsRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Environment:   environment,
		Req:           req,
	}
	mock.lockUpdateComponentResourceConfigs.Lock()
	mock.calls.UpdateComponentResourceConfigs = append(mock.calls.UpdateComponentResourceConfigs, callInfo)
	mock.lockUpdateComponentResourceConfigs.Unlock()
	return mock.UpdateComponentResourceConfigsFunc(ctx, namespaceName, projectName, componentName, environment, req)
}

// UpdateComponentResourceConfigsCalls gets all the calls that were made to UpdateComponentResourceConfigs.
// Check the length with:
//
//	len(mockedOpenChoreoClient.UpdateComponentResourceConfigsCalls())
func (mock *OpenChoreoClientMock) UpdateComponentResourceConfigsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Environment   string
	Req           client.UpdateComponentResourceConfigsRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
		Req           client.UpdateComponentResourceConfigsRequest
	}
	mock.lockUpdateComponentResourceConfigs.RLock()
	calls = mock.calls.UpdateComponentResourceConfigs
	mock.lockUpdateComponentResourceConfigs.RUnlock()
	return calls
}
