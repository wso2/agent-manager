// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package clientmocks

import (
	"context"
	"sync"

	"github.com/wso2/ai-agent-management-platform/agent-manager-service/clients/openchoreosvc/client"
	"github.com/wso2/ai-agent-management-platform/agent-manager-service/models"
)

// OpenChoreoClientMock is a mock implementation of client.OpenChoreoClient.
//
//	func TestSomethingThatUsesOpenChoreoClient(t *testing.T) {
//
//		// make and configure a mocked client.OpenChoreoClient
//		mockedOpenChoreoClient := &OpenChoreoClientMock{
//			AttachTraitFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) error {
//				panic("mock out the AttachTrait method")
//			},
//			ComponentExistsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, verifyProject bool) (bool, error) {
//				panic("mock out the ComponentExists method")
//			},
//			CreateComponentFunc: func(ctx context.Context, namespaceName string, projectName string, req client.CreateComponentRequest) error {
//				panic("mock out the CreateComponent method")
//			},
//			CreateProjectFunc: func(ctx context.Context, namespaceName string, req client.CreateProjectRequest) error {
//				panic("mock out the CreateProject method")
//			},
//			DeleteComponentFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string) error {
//				panic("mock out the DeleteComponent method")
//			},
//			DeleteProjectFunc: func(ctx context.Context, namespaceName string, projectName string) error {
//				panic("mock out the DeleteProject method")
//			},
//			DeployFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.DeployRequest) error {
//				panic("mock out the Deploy method")
//			},
//			GetBuildFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, buildName string) (*models.BuildDetailsResponse, error) {
//				panic("mock out the GetBuild method")
//			},
//			GetComponentFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string) (*models.AgentResponse, error) {
//				panic("mock out the GetComponent method")
//			},
//			GetComponentConfigurationsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) ([]models.EnvVars, error) {
//				panic("mock out the GetComponentConfigurations method")
//			},
//			GetComponentEndpointsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (map[string]models.EndpointsResponse, error) {
//				panic("mock out the GetComponentEndpoints method")
//			},
//			GetDeploymentsFunc: func(ctx context.Context, namespaceName string, pipelineName string, projectName string, componentName string) ([]*models.DeploymentResponse, error) {
//				panic("mock out the GetDeployments method")
//			},
//			GetEnvironmentFunc: func(ctx context.Context, namespaceName string, environmentName string) (*models.EnvironmentResponse, error) {
//				panic("mock out the GetEnvironment method")
//			},
//			GetOrganizationFunc: func(ctx context.Context, orgName string) (*models.OrganizationResponse, error) {
//				panic("mock out the GetOrganization method")
//			},
//			GetProjectFunc: func(ctx context.Context, namespaceName string, projectName string) (*models.ProjectResponse, error) {
//				panic("mock out the GetProject method")
//			},
//			GetProjectDeploymentPipelineFunc: func(ctx context.Context, namespaceName string, projectName string) (*models.DeploymentPipelineResponse, error) {
//				panic("mock out the GetProjectDeploymentPipeline method")
//			},
//			ListBuildsFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string) ([]*models.BuildResponse, error) {
//				panic("mock out the ListBuilds method")
//			},
//			ListComponentsFunc: func(ctx context.Context, namespaceName string, projectName string) ([]*models.AgentResponse, error) {
//				panic("mock out the ListComponents method")
//			},
//			ListDataPlanesFunc: func(ctx context.Context, namespaceName string) ([]*models.DataPlaneResponse, error) {
//				panic("mock out the ListDataPlanes method")
//			},
//			ListDeploymentPipelinesFunc: func(ctx context.Context, namespaceName string) ([]*models.DeploymentPipelineResponse, error) {
//				panic("mock out the ListDeploymentPipelines method")
//			},
//			ListEnvironmentsFunc: func(ctx context.Context, namespaceName string) ([]*models.EnvironmentResponse, error) {
//				panic("mock out the ListEnvironments method")
//			},
//			ListOrganizationsFunc: func(ctx context.Context) ([]*models.OrganizationResponse, error) {
//				panic("mock out the ListOrganizations method")
//			},
//			ListProjectsFunc: func(ctx context.Context, namespaceName string) ([]*models.ProjectResponse, error) {
//				panic("mock out the ListProjects method")
//			},
//			PatchProjectFunc: func(ctx context.Context, namespaceName string, projectName string, req client.PatchProjectRequest) error {
//				panic("mock out the PatchProject method")
//			},
//			TriggerBuildFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, commitID string) (*models.BuildResponse, error) {
//				panic("mock out the TriggerBuild method")
//			},
//			UpdateComponentBasicInfoFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBasicInfoRequest) error {
//				panic("mock out the UpdateComponentBasicInfo method")
//			},
//			UpdateComponentBuildParametersFunc: func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBuildParametersRequest) error {
//				panic("mock out the UpdateComponentBuildParameters method")
//			},
//		}
//
//		// use mockedOpenChoreoClient in code that requires client.OpenChoreoClient
//		// and then make assertions.
//
//	}
type OpenChoreoClientMock struct {
	// AttachTraitFunc mocks the AttachTrait method.
	AttachTraitFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) error

	// ComponentExistsFunc mocks the ComponentExists method.
	ComponentExistsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, verifyProject bool) (bool, error)

	// CreateComponentFunc mocks the CreateComponent method.
	CreateComponentFunc func(ctx context.Context, namespaceName string, projectName string, req client.CreateComponentRequest) error

	// CreateProjectFunc mocks the CreateProject method.
	CreateProjectFunc func(ctx context.Context, namespaceName string, req client.CreateProjectRequest) error

	// DeleteComponentFunc mocks the DeleteComponent method.
	DeleteComponentFunc func(ctx context.Context, namespaceName string, projectName string, componentName string) error

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(ctx context.Context, namespaceName string, projectName string) error

	// DeployFunc mocks the Deploy method.
	DeployFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.DeployRequest) error

	// GetBuildFunc mocks the GetBuild method.
	GetBuildFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, buildName string) (*models.BuildDetailsResponse, error)

	// GetComponentFunc mocks the GetComponent method.
	GetComponentFunc func(ctx context.Context, namespaceName string, projectName string, componentName string) (*models.AgentResponse, error)

	// GetComponentConfigurationsFunc mocks the GetComponentConfigurations method.
	GetComponentConfigurationsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) ([]models.EnvVars, error)

	// GetComponentEndpointsFunc mocks the GetComponentEndpoints method.
	GetComponentEndpointsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (map[string]models.EndpointsResponse, error)

	// GetDeploymentsFunc mocks the GetDeployments method.
	GetDeploymentsFunc func(ctx context.Context, namespaceName string, pipelineName string, projectName string, componentName string) ([]*models.DeploymentResponse, error)

	// GetEnvironmentFunc mocks the GetEnvironment method.
	GetEnvironmentFunc func(ctx context.Context, namespaceName string, environmentName string) (*models.EnvironmentResponse, error)

	// GetOrganizationFunc mocks the GetOrganization method.
	GetOrganizationFunc func(ctx context.Context, orgName string) (*models.OrganizationResponse, error)

	// GetProjectFunc mocks the GetProject method.
	GetProjectFunc func(ctx context.Context, namespaceName string, projectName string) (*models.ProjectResponse, error)

	// GetProjectDeploymentPipelineFunc mocks the GetProjectDeploymentPipeline method.
	GetProjectDeploymentPipelineFunc func(ctx context.Context, namespaceName string, projectName string) (*models.DeploymentPipelineResponse, error)

	// ListBuildsFunc mocks the ListBuilds method.
	ListBuildsFunc func(ctx context.Context, namespaceName string, projectName string, componentName string) ([]*models.BuildResponse, error)

	// ListComponentsFunc mocks the ListComponents method.
	ListComponentsFunc func(ctx context.Context, namespaceName string, projectName string) ([]*models.AgentResponse, error)

	// ListDataPlanesFunc mocks the ListDataPlanes method.
	ListDataPlanesFunc func(ctx context.Context, namespaceName string) ([]*models.DataPlaneResponse, error)

	// ListDeploymentPipelinesFunc mocks the ListDeploymentPipelines method.
	ListDeploymentPipelinesFunc func(ctx context.Context, namespaceName string) ([]*models.DeploymentPipelineResponse, error)

	// ListEnvironmentsFunc mocks the ListEnvironments method.
	ListEnvironmentsFunc func(ctx context.Context, namespaceName string) ([]*models.EnvironmentResponse, error)

	// ListOrganizationsFunc mocks the ListOrganizations method.
	ListOrganizationsFunc func(ctx context.Context) ([]*models.OrganizationResponse, error)

	// ListProjectsFunc mocks the ListProjects method.
	ListProjectsFunc func(ctx context.Context, namespaceName string) ([]*models.ProjectResponse, error)

	// PatchProjectFunc mocks the PatchProject method.
	PatchProjectFunc func(ctx context.Context, namespaceName string, projectName string, req client.PatchProjectRequest) error

	// TriggerBuildFunc mocks the TriggerBuild method.
	TriggerBuildFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, commitID string) (*models.BuildResponse, error)

	// UpdateComponentBasicInfoFunc mocks the UpdateComponentBasicInfo method.
	UpdateComponentBasicInfoFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBasicInfoRequest) error

	// UpdateComponentBuildParametersFunc mocks the UpdateComponentBuildParameters method.
	UpdateComponentBuildParametersFunc func(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBuildParametersRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// AttachTrait holds details about calls to the AttachTrait method.
		AttachTrait []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// TraitType is the traitType argument value.
			TraitType client.TraitType
		}
		// ComponentExists holds details about calls to the ComponentExists method.
		ComponentExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// VerifyProject is the verifyProject argument value.
			VerifyProject bool
		}
		// CreateComponent holds details about calls to the CreateComponent method.
		CreateComponent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// Req is the req argument value.
			Req client.CreateComponentRequest
		}
		// CreateProject holds details about calls to the CreateProject method.
		CreateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// Req is the req argument value.
			Req client.CreateProjectRequest
		}
		// DeleteComponent holds details about calls to the DeleteComponent method.
		DeleteComponent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// Deploy holds details about calls to the Deploy method.
		Deploy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Req is the req argument value.
			Req client.DeployRequest
		}
		// GetBuild holds details about calls to the GetBuild method.
		GetBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// BuildName is the buildName argument value.
			BuildName string
		}
		// GetComponent holds details about calls to the GetComponent method.
		GetComponent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// GetComponentConfigurations holds details about calls to the GetComponentConfigurations method.
		GetComponentConfigurations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Environment is the environment argument value.
			Environment string
		}
		// GetComponentEndpoints holds details about calls to the GetComponentEndpoints method.
		GetComponentEndpoints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Environment is the environment argument value.
			Environment string
		}
		// GetDeployments holds details about calls to the GetDeployments method.
		GetDeployments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// PipelineName is the pipelineName argument value.
			PipelineName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// GetEnvironment holds details about calls to the GetEnvironment method.
		GetEnvironment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// EnvironmentName is the environmentName argument value.
			EnvironmentName string
		}
		// GetOrganization holds details about calls to the GetOrganization method.
		GetOrganization []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrgName is the orgName argument value.
			OrgName string
		}
		// GetProject holds details about calls to the GetProject method.
		GetProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// GetProjectDeploymentPipeline holds details about calls to the GetProjectDeploymentPipeline method.
		GetProjectDeploymentPipeline []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// ListBuilds holds details about calls to the ListBuilds method.
		ListBuilds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
		}
		// ListComponents holds details about calls to the ListComponents method.
		ListComponents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// ListDataPlanes holds details about calls to the ListDataPlanes method.
		ListDataPlanes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// ListDeploymentPipelines holds details about calls to the ListDeploymentPipelines method.
		ListDeploymentPipelines []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// ListEnvironments holds details about calls to the ListEnvironments method.
		ListEnvironments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// ListOrganizations holds details about calls to the ListOrganizations method.
		ListOrganizations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListProjects holds details about calls to the ListProjects method.
		ListProjects []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
		}
		// PatchProject holds details about calls to the PatchProject method.
		PatchProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// Req is the req argument value.
			Req client.PatchProjectRequest
		}
		// TriggerBuild holds details about calls to the TriggerBuild method.
		TriggerBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// CommitID is the commitID argument value.
			CommitID string
		}
		// UpdateComponentBasicInfo holds details about calls to the UpdateComponentBasicInfo method.
		UpdateComponentBasicInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Req is the req argument value.
			Req client.UpdateComponentBasicInfoRequest
		}
		// UpdateComponentBuildParameters holds details about calls to the UpdateComponentBuildParameters method.
		UpdateComponentBuildParameters []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NamespaceName is the namespaceName argument value.
			NamespaceName string
			// ProjectName is the projectName argument value.
			ProjectName string
			// ComponentName is the componentName argument value.
			ComponentName string
			// Req is the req argument value.
			Req client.UpdateComponentBuildParametersRequest
		}
	}
	lockAttachTrait                    sync.RWMutex
	lockComponentExists                sync.RWMutex
	lockCreateComponent                sync.RWMutex
	lockCreateProject                  sync.RWMutex
	lockDeleteComponent                sync.RWMutex
	lockDeleteProject                  sync.RWMutex
	lockDeploy                         sync.RWMutex
	lockGetBuild                       sync.RWMutex
	lockGetComponent                   sync.RWMutex
	lockGetComponentConfigurations     sync.RWMutex
	lockGetComponentEndpoints          sync.RWMutex
	lockGetDeployments                 sync.RWMutex
	lockGetEnvironment                 sync.RWMutex
	lockGetOrganization                sync.RWMutex
	lockGetProject                     sync.RWMutex
	lockGetProjectDeploymentPipeline   sync.RWMutex
	lockListBuilds                     sync.RWMutex
	lockListComponents                 sync.RWMutex
	lockListDataPlanes                 sync.RWMutex
	lockListDeploymentPipelines        sync.RWMutex
	lockListEnvironments               sync.RWMutex
	lockListOrganizations              sync.RWMutex
	lockListProjects                   sync.RWMutex
	lockPatchProject                   sync.RWMutex
	lockTriggerBuild                   sync.RWMutex
	lockUpdateComponentBasicInfo       sync.RWMutex
	lockUpdateComponentBuildParameters sync.RWMutex
}

// AttachTrait calls AttachTraitFunc.
func (mock *OpenChoreoClientMock) AttachTrait(ctx context.Context, namespaceName string, projectName string, componentName string, traitType client.TraitType) error {
	if mock.AttachTraitFunc == nil {
		panic("OpenChoreoClientMock.AttachTraitFunc: method is nil but OpenChoreoClient.AttachTrait was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		TraitType:     traitType,
	}
	mock.lockAttachTrait.Lock()
	mock.calls.AttachTrait = append(mock.calls.AttachTrait, callInfo)
	mock.lockAttachTrait.Unlock()
	return mock.AttachTraitFunc(ctx, namespaceName, projectName, componentName, traitType)
}

// AttachTraitCalls gets all the calls that were made to AttachTrait.
// Check the length with:
//
//	len(mockedOpenChoreoClient.AttachTraitCalls())
func (mock *OpenChoreoClientMock) AttachTraitCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	TraitType     client.TraitType
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		TraitType     client.TraitType
	}
	mock.lockAttachTrait.RLock()
	calls = mock.calls.AttachTrait
	mock.lockAttachTrait.RUnlock()
	return calls
}

// ComponentExists calls ComponentExistsFunc.
func (mock *OpenChoreoClientMock) ComponentExists(ctx context.Context, namespaceName string, projectName string, componentName string, verifyProject bool) (bool, error) {
	if mock.ComponentExistsFunc == nil {
		panic("OpenChoreoClientMock.ComponentExistsFunc: method is nil but OpenChoreoClient.ComponentExists was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		VerifyProject bool
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		VerifyProject: verifyProject,
	}
	mock.lockComponentExists.Lock()
	mock.calls.ComponentExists = append(mock.calls.ComponentExists, callInfo)
	mock.lockComponentExists.Unlock()
	return mock.ComponentExistsFunc(ctx, namespaceName, projectName, componentName, verifyProject)
}

// ComponentExistsCalls gets all the calls that were made to ComponentExists.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ComponentExistsCalls())
func (mock *OpenChoreoClientMock) ComponentExistsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	VerifyProject bool
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		VerifyProject bool
	}
	mock.lockComponentExists.RLock()
	calls = mock.calls.ComponentExists
	mock.lockComponentExists.RUnlock()
	return calls
}

// CreateComponent calls CreateComponentFunc.
func (mock *OpenChoreoClientMock) CreateComponent(ctx context.Context, namespaceName string, projectName string, req client.CreateComponentRequest) error {
	if mock.CreateComponentFunc == nil {
		panic("OpenChoreoClientMock.CreateComponentFunc: method is nil but OpenChoreoClient.CreateComponent was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.CreateComponentRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		Req:           req,
	}
	mock.lockCreateComponent.Lock()
	mock.calls.CreateComponent = append(mock.calls.CreateComponent, callInfo)
	mock.lockCreateComponent.Unlock()
	return mock.CreateComponentFunc(ctx, namespaceName, projectName, req)
}

// CreateComponentCalls gets all the calls that were made to CreateComponent.
// Check the length with:
//
//	len(mockedOpenChoreoClient.CreateComponentCalls())
func (mock *OpenChoreoClientMock) CreateComponentCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	Req           client.CreateComponentRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.CreateComponentRequest
	}
	mock.lockCreateComponent.RLock()
	calls = mock.calls.CreateComponent
	mock.lockCreateComponent.RUnlock()
	return calls
}

// CreateProject calls CreateProjectFunc.
func (mock *OpenChoreoClientMock) CreateProject(ctx context.Context, namespaceName string, req client.CreateProjectRequest) error {
	if mock.CreateProjectFunc == nil {
		panic("OpenChoreoClientMock.CreateProjectFunc: method is nil but OpenChoreoClient.CreateProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		Req           client.CreateProjectRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		Req:           req,
	}
	mock.lockCreateProject.Lock()
	mock.calls.CreateProject = append(mock.calls.CreateProject, callInfo)
	mock.lockCreateProject.Unlock()
	return mock.CreateProjectFunc(ctx, namespaceName, req)
}

// CreateProjectCalls gets all the calls that were made to CreateProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.CreateProjectCalls())
func (mock *OpenChoreoClientMock) CreateProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	Req           client.CreateProjectRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		Req           client.CreateProjectRequest
	}
	mock.lockCreateProject.RLock()
	calls = mock.calls.CreateProject
	mock.lockCreateProject.RUnlock()
	return calls
}

// DeleteComponent calls DeleteComponentFunc.
func (mock *OpenChoreoClientMock) DeleteComponent(ctx context.Context, namespaceName string, projectName string, componentName string) error {
	if mock.DeleteComponentFunc == nil {
		panic("OpenChoreoClientMock.DeleteComponentFunc: method is nil but OpenChoreoClient.DeleteComponent was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockDeleteComponent.Lock()
	mock.calls.DeleteComponent = append(mock.calls.DeleteComponent, callInfo)
	mock.lockDeleteComponent.Unlock()
	return mock.DeleteComponentFunc(ctx, namespaceName, projectName, componentName)
}

// DeleteComponentCalls gets all the calls that were made to DeleteComponent.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeleteComponentCalls())
func (mock *OpenChoreoClientMock) DeleteComponentCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}
	mock.lockDeleteComponent.RLock()
	calls = mock.calls.DeleteComponent
	mock.lockDeleteComponent.RUnlock()
	return calls
}

// DeleteProject calls DeleteProjectFunc.
func (mock *OpenChoreoClientMock) DeleteProject(ctx context.Context, namespaceName string, projectName string) error {
	if mock.DeleteProjectFunc == nil {
		panic("OpenChoreoClientMock.DeleteProjectFunc: method is nil but OpenChoreoClient.DeleteProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(ctx, namespaceName, projectName)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeleteProjectCalls())
func (mock *OpenChoreoClientMock) DeleteProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// Deploy calls DeployFunc.
func (mock *OpenChoreoClientMock) Deploy(ctx context.Context, namespaceName string, projectName string, componentName string, req client.DeployRequest) error {
	if mock.DeployFunc == nil {
		panic("OpenChoreoClientMock.DeployFunc: method is nil but OpenChoreoClient.Deploy was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.DeployRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Req:           req,
	}
	mock.lockDeploy.Lock()
	mock.calls.Deploy = append(mock.calls.Deploy, callInfo)
	mock.lockDeploy.Unlock()
	return mock.DeployFunc(ctx, namespaceName, projectName, componentName, req)
}

// DeployCalls gets all the calls that were made to Deploy.
// Check the length with:
//
//	len(mockedOpenChoreoClient.DeployCalls())
func (mock *OpenChoreoClientMock) DeployCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Req           client.DeployRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.DeployRequest
	}
	mock.lockDeploy.RLock()
	calls = mock.calls.Deploy
	mock.lockDeploy.RUnlock()
	return calls
}

// GetBuild calls GetBuildFunc.
func (mock *OpenChoreoClientMock) GetBuild(ctx context.Context, namespaceName string, projectName string, componentName string, buildName string) (*models.BuildDetailsResponse, error) {
	if mock.GetBuildFunc == nil {
		panic("OpenChoreoClientMock.GetBuildFunc: method is nil but OpenChoreoClient.GetBuild was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		BuildName     string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		BuildName:     buildName,
	}
	mock.lockGetBuild.Lock()
	mock.calls.GetBuild = append(mock.calls.GetBuild, callInfo)
	mock.lockGetBuild.Unlock()
	return mock.GetBuildFunc(ctx, namespaceName, projectName, componentName, buildName)
}

// GetBuildCalls gets all the calls that were made to GetBuild.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetBuildCalls())
func (mock *OpenChoreoClientMock) GetBuildCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	BuildName     string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		BuildName     string
	}
	mock.lockGetBuild.RLock()
	calls = mock.calls.GetBuild
	mock.lockGetBuild.RUnlock()
	return calls
}

// GetComponent calls GetComponentFunc.
func (mock *OpenChoreoClientMock) GetComponent(ctx context.Context, namespaceName string, projectName string, componentName string) (*models.AgentResponse, error) {
	if mock.GetComponentFunc == nil {
		panic("OpenChoreoClientMock.GetComponentFunc: method is nil but OpenChoreoClient.GetComponent was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockGetComponent.Lock()
	mock.calls.GetComponent = append(mock.calls.GetComponent, callInfo)
	mock.lockGetComponent.Unlock()
	return mock.GetComponentFunc(ctx, namespaceName, projectName, componentName)
}

// GetComponentCalls gets all the calls that were made to GetComponent.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentCalls())
func (mock *OpenChoreoClientMock) GetComponentCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}
	mock.lockGetComponent.RLock()
	calls = mock.calls.GetComponent
	mock.lockGetComponent.RUnlock()
	return calls
}

// GetComponentConfigurations calls GetComponentConfigurationsFunc.
func (mock *OpenChoreoClientMock) GetComponentConfigurations(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) ([]models.EnvVars, error) {
	if mock.GetComponentConfigurationsFunc == nil {
		panic("OpenChoreoClientMock.GetComponentConfigurationsFunc: method is nil but OpenChoreoClient.GetComponentConfigurations was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Environment:   environment,
	}
	mock.lockGetComponentConfigurations.Lock()
	mock.calls.GetComponentConfigurations = append(mock.calls.GetComponentConfigurations, callInfo)
	mock.lockGetComponentConfigurations.Unlock()
	return mock.GetComponentConfigurationsFunc(ctx, namespaceName, projectName, componentName, environment)
}

// GetComponentConfigurationsCalls gets all the calls that were made to GetComponentConfigurations.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentConfigurationsCalls())
func (mock *OpenChoreoClientMock) GetComponentConfigurationsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Environment   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}
	mock.lockGetComponentConfigurations.RLock()
	calls = mock.calls.GetComponentConfigurations
	mock.lockGetComponentConfigurations.RUnlock()
	return calls
}

// GetComponentEndpoints calls GetComponentEndpointsFunc.
func (mock *OpenChoreoClientMock) GetComponentEndpoints(ctx context.Context, namespaceName string, projectName string, componentName string, environment string) (map[string]models.EndpointsResponse, error) {
	if mock.GetComponentEndpointsFunc == nil {
		panic("OpenChoreoClientMock.GetComponentEndpointsFunc: method is nil but OpenChoreoClient.GetComponentEndpoints was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Environment:   environment,
	}
	mock.lockGetComponentEndpoints.Lock()
	mock.calls.GetComponentEndpoints = append(mock.calls.GetComponentEndpoints, callInfo)
	mock.lockGetComponentEndpoints.Unlock()
	return mock.GetComponentEndpointsFunc(ctx, namespaceName, projectName, componentName, environment)
}

// GetComponentEndpointsCalls gets all the calls that were made to GetComponentEndpoints.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetComponentEndpointsCalls())
func (mock *OpenChoreoClientMock) GetComponentEndpointsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Environment   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Environment   string
	}
	mock.lockGetComponentEndpoints.RLock()
	calls = mock.calls.GetComponentEndpoints
	mock.lockGetComponentEndpoints.RUnlock()
	return calls
}

// GetDeployments calls GetDeploymentsFunc.
func (mock *OpenChoreoClientMock) GetDeployments(ctx context.Context, namespaceName string, pipelineName string, projectName string, componentName string) ([]*models.DeploymentResponse, error) {
	if mock.GetDeploymentsFunc == nil {
		panic("OpenChoreoClientMock.GetDeploymentsFunc: method is nil but OpenChoreoClient.GetDeployments was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		PipelineName  string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		PipelineName:  pipelineName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockGetDeployments.Lock()
	mock.calls.GetDeployments = append(mock.calls.GetDeployments, callInfo)
	mock.lockGetDeployments.Unlock()
	return mock.GetDeploymentsFunc(ctx, namespaceName, pipelineName, projectName, componentName)
}

// GetDeploymentsCalls gets all the calls that were made to GetDeployments.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetDeploymentsCalls())
func (mock *OpenChoreoClientMock) GetDeploymentsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	PipelineName  string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		PipelineName  string
		ProjectName   string
		ComponentName string
	}
	mock.lockGetDeployments.RLock()
	calls = mock.calls.GetDeployments
	mock.lockGetDeployments.RUnlock()
	return calls
}

// GetEnvironment calls GetEnvironmentFunc.
func (mock *OpenChoreoClientMock) GetEnvironment(ctx context.Context, namespaceName string, environmentName string) (*models.EnvironmentResponse, error) {
	if mock.GetEnvironmentFunc == nil {
		panic("OpenChoreoClientMock.GetEnvironmentFunc: method is nil but OpenChoreoClient.GetEnvironment was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		NamespaceName   string
		EnvironmentName string
	}{
		Ctx:             ctx,
		NamespaceName:   namespaceName,
		EnvironmentName: environmentName,
	}
	mock.lockGetEnvironment.Lock()
	mock.calls.GetEnvironment = append(mock.calls.GetEnvironment, callInfo)
	mock.lockGetEnvironment.Unlock()
	return mock.GetEnvironmentFunc(ctx, namespaceName, environmentName)
}

// GetEnvironmentCalls gets all the calls that were made to GetEnvironment.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetEnvironmentCalls())
func (mock *OpenChoreoClientMock) GetEnvironmentCalls() []struct {
	Ctx             context.Context
	NamespaceName   string
	EnvironmentName string
} {
	var calls []struct {
		Ctx             context.Context
		NamespaceName   string
		EnvironmentName string
	}
	mock.lockGetEnvironment.RLock()
	calls = mock.calls.GetEnvironment
	mock.lockGetEnvironment.RUnlock()
	return calls
}

// GetOrganization calls GetOrganizationFunc.
func (mock *OpenChoreoClientMock) GetOrganization(ctx context.Context, orgName string) (*models.OrganizationResponse, error) {
	if mock.GetOrganizationFunc == nil {
		panic("OpenChoreoClientMock.GetOrganizationFunc: method is nil but OpenChoreoClient.GetOrganization was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OrgName string
	}{
		Ctx:     ctx,
		OrgName: orgName,
	}
	mock.lockGetOrganization.Lock()
	mock.calls.GetOrganization = append(mock.calls.GetOrganization, callInfo)
	mock.lockGetOrganization.Unlock()
	return mock.GetOrganizationFunc(ctx, orgName)
}

// GetOrganizationCalls gets all the calls that were made to GetOrganization.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetOrganizationCalls())
func (mock *OpenChoreoClientMock) GetOrganizationCalls() []struct {
	Ctx     context.Context
	OrgName string
} {
	var calls []struct {
		Ctx     context.Context
		OrgName string
	}
	mock.lockGetOrganization.RLock()
	calls = mock.calls.GetOrganization
	mock.lockGetOrganization.RUnlock()
	return calls
}

// GetProject calls GetProjectFunc.
func (mock *OpenChoreoClientMock) GetProject(ctx context.Context, namespaceName string, projectName string) (*models.ProjectResponse, error) {
	if mock.GetProjectFunc == nil {
		panic("OpenChoreoClientMock.GetProjectFunc: method is nil but OpenChoreoClient.GetProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockGetProject.Lock()
	mock.calls.GetProject = append(mock.calls.GetProject, callInfo)
	mock.lockGetProject.Unlock()
	return mock.GetProjectFunc(ctx, namespaceName, projectName)
}

// GetProjectCalls gets all the calls that were made to GetProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetProjectCalls())
func (mock *OpenChoreoClientMock) GetProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockGetProject.RLock()
	calls = mock.calls.GetProject
	mock.lockGetProject.RUnlock()
	return calls
}

// GetProjectDeploymentPipeline calls GetProjectDeploymentPipelineFunc.
func (mock *OpenChoreoClientMock) GetProjectDeploymentPipeline(ctx context.Context, namespaceName string, projectName string) (*models.DeploymentPipelineResponse, error) {
	if mock.GetProjectDeploymentPipelineFunc == nil {
		panic("OpenChoreoClientMock.GetProjectDeploymentPipelineFunc: method is nil but OpenChoreoClient.GetProjectDeploymentPipeline was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockGetProjectDeploymentPipeline.Lock()
	mock.calls.GetProjectDeploymentPipeline = append(mock.calls.GetProjectDeploymentPipeline, callInfo)
	mock.lockGetProjectDeploymentPipeline.Unlock()
	return mock.GetProjectDeploymentPipelineFunc(ctx, namespaceName, projectName)
}

// GetProjectDeploymentPipelineCalls gets all the calls that were made to GetProjectDeploymentPipeline.
// Check the length with:
//
//	len(mockedOpenChoreoClient.GetProjectDeploymentPipelineCalls())
func (mock *OpenChoreoClientMock) GetProjectDeploymentPipelineCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockGetProjectDeploymentPipeline.RLock()
	calls = mock.calls.GetProjectDeploymentPipeline
	mock.lockGetProjectDeploymentPipeline.RUnlock()
	return calls
}

// ListBuilds calls ListBuildsFunc.
func (mock *OpenChoreoClientMock) ListBuilds(ctx context.Context, namespaceName string, projectName string, componentName string) ([]*models.BuildResponse, error) {
	if mock.ListBuildsFunc == nil {
		panic("OpenChoreoClientMock.ListBuildsFunc: method is nil but OpenChoreoClient.ListBuilds was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
	}
	mock.lockListBuilds.Lock()
	mock.calls.ListBuilds = append(mock.calls.ListBuilds, callInfo)
	mock.lockListBuilds.Unlock()
	return mock.ListBuildsFunc(ctx, namespaceName, projectName, componentName)
}

// ListBuildsCalls gets all the calls that were made to ListBuilds.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListBuildsCalls())
func (mock *OpenChoreoClientMock) ListBuildsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
	}
	mock.lockListBuilds.RLock()
	calls = mock.calls.ListBuilds
	mock.lockListBuilds.RUnlock()
	return calls
}

// ListComponents calls ListComponentsFunc.
func (mock *OpenChoreoClientMock) ListComponents(ctx context.Context, namespaceName string, projectName string) ([]*models.AgentResponse, error) {
	if mock.ListComponentsFunc == nil {
		panic("OpenChoreoClientMock.ListComponentsFunc: method is nil but OpenChoreoClient.ListComponents was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
	}
	mock.lockListComponents.Lock()
	mock.calls.ListComponents = append(mock.calls.ListComponents, callInfo)
	mock.lockListComponents.Unlock()
	return mock.ListComponentsFunc(ctx, namespaceName, projectName)
}

// ListComponentsCalls gets all the calls that were made to ListComponents.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListComponentsCalls())
func (mock *OpenChoreoClientMock) ListComponentsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
	}
	mock.lockListComponents.RLock()
	calls = mock.calls.ListComponents
	mock.lockListComponents.RUnlock()
	return calls
}

// ListDataPlanes calls ListDataPlanesFunc.
func (mock *OpenChoreoClientMock) ListDataPlanes(ctx context.Context, namespaceName string) ([]*models.DataPlaneResponse, error) {
	if mock.ListDataPlanesFunc == nil {
		panic("OpenChoreoClientMock.ListDataPlanesFunc: method is nil but OpenChoreoClient.ListDataPlanes was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListDataPlanes.Lock()
	mock.calls.ListDataPlanes = append(mock.calls.ListDataPlanes, callInfo)
	mock.lockListDataPlanes.Unlock()
	return mock.ListDataPlanesFunc(ctx, namespaceName)
}

// ListDataPlanesCalls gets all the calls that were made to ListDataPlanes.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListDataPlanesCalls())
func (mock *OpenChoreoClientMock) ListDataPlanesCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListDataPlanes.RLock()
	calls = mock.calls.ListDataPlanes
	mock.lockListDataPlanes.RUnlock()
	return calls
}

// ListDeploymentPipelines calls ListDeploymentPipelinesFunc.
func (mock *OpenChoreoClientMock) ListDeploymentPipelines(ctx context.Context, namespaceName string) ([]*models.DeploymentPipelineResponse, error) {
	if mock.ListDeploymentPipelinesFunc == nil {
		panic("OpenChoreoClientMock.ListDeploymentPipelinesFunc: method is nil but OpenChoreoClient.ListDeploymentPipelines was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListDeploymentPipelines.Lock()
	mock.calls.ListDeploymentPipelines = append(mock.calls.ListDeploymentPipelines, callInfo)
	mock.lockListDeploymentPipelines.Unlock()
	return mock.ListDeploymentPipelinesFunc(ctx, namespaceName)
}

// ListDeploymentPipelinesCalls gets all the calls that were made to ListDeploymentPipelines.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListDeploymentPipelinesCalls())
func (mock *OpenChoreoClientMock) ListDeploymentPipelinesCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListDeploymentPipelines.RLock()
	calls = mock.calls.ListDeploymentPipelines
	mock.lockListDeploymentPipelines.RUnlock()
	return calls
}

// ListEnvironments calls ListEnvironmentsFunc.
func (mock *OpenChoreoClientMock) ListEnvironments(ctx context.Context, namespaceName string) ([]*models.EnvironmentResponse, error) {
	if mock.ListEnvironmentsFunc == nil {
		panic("OpenChoreoClientMock.ListEnvironmentsFunc: method is nil but OpenChoreoClient.ListEnvironments was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListEnvironments.Lock()
	mock.calls.ListEnvironments = append(mock.calls.ListEnvironments, callInfo)
	mock.lockListEnvironments.Unlock()
	return mock.ListEnvironmentsFunc(ctx, namespaceName)
}

// ListEnvironmentsCalls gets all the calls that were made to ListEnvironments.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListEnvironmentsCalls())
func (mock *OpenChoreoClientMock) ListEnvironmentsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListEnvironments.RLock()
	calls = mock.calls.ListEnvironments
	mock.lockListEnvironments.RUnlock()
	return calls
}

// ListOrganizations calls ListOrganizationsFunc.
func (mock *OpenChoreoClientMock) ListOrganizations(ctx context.Context) ([]*models.OrganizationResponse, error) {
	if mock.ListOrganizationsFunc == nil {
		panic("OpenChoreoClientMock.ListOrganizationsFunc: method is nil but OpenChoreoClient.ListOrganizations was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListOrganizations.Lock()
	mock.calls.ListOrganizations = append(mock.calls.ListOrganizations, callInfo)
	mock.lockListOrganizations.Unlock()
	return mock.ListOrganizationsFunc(ctx)
}

// ListOrganizationsCalls gets all the calls that were made to ListOrganizations.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListOrganizationsCalls())
func (mock *OpenChoreoClientMock) ListOrganizationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListOrganizations.RLock()
	calls = mock.calls.ListOrganizations
	mock.lockListOrganizations.RUnlock()
	return calls
}

// ListProjects calls ListProjectsFunc.
func (mock *OpenChoreoClientMock) ListProjects(ctx context.Context, namespaceName string) ([]*models.ProjectResponse, error) {
	if mock.ListProjectsFunc == nil {
		panic("OpenChoreoClientMock.ListProjectsFunc: method is nil but OpenChoreoClient.ListProjects was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
	}
	mock.lockListProjects.Lock()
	mock.calls.ListProjects = append(mock.calls.ListProjects, callInfo)
	mock.lockListProjects.Unlock()
	return mock.ListProjectsFunc(ctx, namespaceName)
}

// ListProjectsCalls gets all the calls that were made to ListProjects.
// Check the length with:
//
//	len(mockedOpenChoreoClient.ListProjectsCalls())
func (mock *OpenChoreoClientMock) ListProjectsCalls() []struct {
	Ctx           context.Context
	NamespaceName string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
	}
	mock.lockListProjects.RLock()
	calls = mock.calls.ListProjects
	mock.lockListProjects.RUnlock()
	return calls
}

// PatchProject calls PatchProjectFunc.
func (mock *OpenChoreoClientMock) PatchProject(ctx context.Context, namespaceName string, projectName string, req client.PatchProjectRequest) error {
	if mock.PatchProjectFunc == nil {
		panic("OpenChoreoClientMock.PatchProjectFunc: method is nil but OpenChoreoClient.PatchProject was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.PatchProjectRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		Req:           req,
	}
	mock.lockPatchProject.Lock()
	mock.calls.PatchProject = append(mock.calls.PatchProject, callInfo)
	mock.lockPatchProject.Unlock()
	return mock.PatchProjectFunc(ctx, namespaceName, projectName, req)
}

// PatchProjectCalls gets all the calls that were made to PatchProject.
// Check the length with:
//
//	len(mockedOpenChoreoClient.PatchProjectCalls())
func (mock *OpenChoreoClientMock) PatchProjectCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	Req           client.PatchProjectRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		Req           client.PatchProjectRequest
	}
	mock.lockPatchProject.RLock()
	calls = mock.calls.PatchProject
	mock.lockPatchProject.RUnlock()
	return calls
}

// TriggerBuild calls TriggerBuildFunc.
func (mock *OpenChoreoClientMock) TriggerBuild(ctx context.Context, namespaceName string, projectName string, componentName string, commitID string) (*models.BuildResponse, error) {
	if mock.TriggerBuildFunc == nil {
		panic("OpenChoreoClientMock.TriggerBuildFunc: method is nil but OpenChoreoClient.TriggerBuild was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		CommitID      string
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		CommitID:      commitID,
	}
	mock.lockTriggerBuild.Lock()
	mock.calls.TriggerBuild = append(mock.calls.TriggerBuild, callInfo)
	mock.lockTriggerBuild.Unlock()
	return mock.TriggerBuildFunc(ctx, namespaceName, projectName, componentName, commitID)
}

// TriggerBuildCalls gets all the calls that were made to TriggerBuild.
// Check the length with:
//
//	len(mockedOpenChoreoClient.TriggerBuildCalls())
func (mock *OpenChoreoClientMock) TriggerBuildCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	CommitID      string
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		CommitID      string
	}
	mock.lockTriggerBuild.RLock()
	calls = mock.calls.TriggerBuild
	mock.lockTriggerBuild.RUnlock()
	return calls
}

// UpdateComponentBasicInfo calls UpdateComponentBasicInfoFunc.
func (mock *OpenChoreoClientMock) UpdateComponentBasicInfo(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBasicInfoRequest) error {
	if mock.UpdateComponentBasicInfoFunc == nil {
		panic("OpenChoreoClientMock.UpdateComponentBasicInfoFunc: method is nil but OpenChoreoClient.UpdateComponentBasicInfo was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBasicInfoRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Req:           req,
	}
	mock.lockUpdateComponentBasicInfo.Lock()
	mock.calls.UpdateComponentBasicInfo = append(mock.calls.UpdateComponentBasicInfo, callInfo)
	mock.lockUpdateComponentBasicInfo.Unlock()
	return mock.UpdateComponentBasicInfoFunc(ctx, namespaceName, projectName, componentName, req)
}

// UpdateComponentBasicInfoCalls gets all the calls that were made to UpdateComponentBasicInfo.
// Check the length with:
//
//	len(mockedOpenChoreoClient.UpdateComponentBasicInfoCalls())
func (mock *OpenChoreoClientMock) UpdateComponentBasicInfoCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Req           client.UpdateComponentBasicInfoRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBasicInfoRequest
	}
	mock.lockUpdateComponentBasicInfo.RLock()
	calls = mock.calls.UpdateComponentBasicInfo
	mock.lockUpdateComponentBasicInfo.RUnlock()
	return calls
}

// UpdateComponentBuildParameters calls UpdateComponentBuildParametersFunc.
func (mock *OpenChoreoClientMock) UpdateComponentBuildParameters(ctx context.Context, namespaceName string, projectName string, componentName string, req client.UpdateComponentBuildParametersRequest) error {
	if mock.UpdateComponentBuildParametersFunc == nil {
		panic("OpenChoreoClientMock.UpdateComponentBuildParametersFunc: method is nil but OpenChoreoClient.UpdateComponentBuildParameters was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBuildParametersRequest
	}{
		Ctx:           ctx,
		NamespaceName: namespaceName,
		ProjectName:   projectName,
		ComponentName: componentName,
		Req:           req,
	}
	mock.lockUpdateComponentBuildParameters.Lock()
	mock.calls.UpdateComponentBuildParameters = append(mock.calls.UpdateComponentBuildParameters, callInfo)
	mock.lockUpdateComponentBuildParameters.Unlock()
	return mock.UpdateComponentBuildParametersFunc(ctx, namespaceName, projectName, componentName, req)
}

// UpdateComponentBuildParametersCalls gets all the calls that were made to UpdateComponentBuildParameters.
// Check the length with:
//
//	len(mockedOpenChoreoClient.UpdateComponentBuildParametersCalls())
func (mock *OpenChoreoClientMock) UpdateComponentBuildParametersCalls() []struct {
	Ctx           context.Context
	NamespaceName string
	ProjectName   string
	ComponentName string
	Req           client.UpdateComponentBuildParametersRequest
} {
	var calls []struct {
		Ctx           context.Context
		NamespaceName string
		ProjectName   string
		ComponentName string
		Req           client.UpdateComponentBuildParametersRequest
	}
	mock.lockUpdateComponentBuildParameters.RLock()
	calls = mock.calls.UpdateComponentBuildParameters
	mock.lockUpdateComponentBuildParameters.RUnlock()
	return calls
}
